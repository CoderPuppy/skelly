// Generated by LiveScript 1.2.0
(function(){
  var LBase, between, LValue, ref$, order, filter, LArray, slice$ = [].slice;
  LBase = require('./base');
  between = require('between');
  LValue = require('./value');
  ref$ = require('scuttlebutt/util'), order = ref$.order, filter = ref$.filter;
  LArray = (function(superclass){
    var prototype = extend$((import$(LArray, superclass).displayName = 'LArray', LArray), superclass).prototype, constructor = LArray;
    function LArray(){
      var vals, i$, len$, val;
      vals = slice$.call(arguments);
      LArray.superclass.call(this);
      this.db = {};
      this.keys = [];
      this._buffer = {};
      this.length = new LValue(0);
      this._hist = {};
      this._historyMap = {};
      for (i$ = 0, len$ = vals.length; i$ < len$; ++i$) {
        val = vals[i$];
        this.push(val);
      }
    }
    prototype.creationArgs = function(){
      return [];
    };
    LArray.mapCreationArgs = function(fn, args){
      return [];
    };
    prototype._register = function(key, val, emit){
      var this$ = this;
      emit == null && (emit = true);
      this.db[key] = val;
      if (emit) {
        this.localUpdate(['d', key, LBase.from(val)]);
      }
      val.on('_update', function(update){
        if (this$.db[key] === val) {
          return this$.localUpdate(['c', key, update]);
        }
      });
      return key;
    };
    prototype._unset = function(key){
      return this.localUpdate(['d', key]);
    };
    prototype.firstKey = function(){
      return this.keys[0];
    };
    prototype.lastKey = function(){
      return this.keys[this.keys.length - 1];
    };
    prototype.insert = function(before, val, after){
      before == null && (before = between.lo);
      after == null && (after = between.hi);
      return this._register(between(before, after), val);
    };
    prototype.first = function(){
      return this.db[this.firstKey];
    };
    prototype.last = function(){
      return this.db[this.lastKey];
    };
    prototype.push = function(val){
      this.insert(this.lastKey(), val);
      return this;
    };
    prototype.unshift = function(val){
      this.insert(null, val, this.firstKey());
      return this;
    };
    prototype.get = function(index){
      return this.db[this.keys[index]];
    };
    prototype.pop = function(){
      var key, val;
      key = this.lastKey();
      val = this.db[key];
      this._unset(key);
      return val;
    };
    prototype.shift = function(){
      var key, val;
      key = this.firstKey();
      val = this.db[key];
      this._unset(key);
      return val;
    };
    prototype.remove = function(index){
      var key, val;
      key = this.keys[index];
      val = this.db[key];
      this._unset(key);
      return val;
    };
    prototype.forEach = function(fn){
      var i$, ref$, len$, i;
      for (i$ = 0, len$ = (ref$ = (fn$.call(this))).length; i$ < len$; ++i$) {
        i = ref$[i$];
        fn.call(this, this.get(i), i);
      }
      return this;
      function fn$(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = this.length.get(); i$ < to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }
    };
    prototype.each = function(fn){
      return this.forEach(fn);
    };
    LArray.mapper = function(fn){
      return null;
    };
    prototype.history = function(sources){
      var hist, key, ref$, update, val, this$ = this;
      hist = [];
      for (key in ref$ = this._hist) {
        update = ref$[key];
        if (!~hist.indexOf(update) && filter(update, sources)) {
          hist.push(update);
        }
      }
      for (key in ref$ = this.db) {
        val = ref$[key];
        hist = hist.concat(val.history(sources).map(fn$));
      }
      return hist.filter(Boolean).sort(order);
      function fn$(update){
        return this$._historyMap[key + "-" + update[2] + "-" + update[1]];
      }
    };
    prototype.applyUpdate = function(update){
      var data, ref$;
      data = update[0];
      switch (data[0]) {
      case 'd':
        this._hist[data[1]] = update;
        if (data[2] != null) {
          if (!(this.db[data[1]] != null && LBase.type(this.db[data[1]]) === data[2][0])) {
            this._register(data[1], LBase.create.apply(LBase, data[2]), false);
          }
        }
        if (this.keys.indexOf(data[1]) === -1) {
          this.keys.push(data[1]);
        }
        this.keys.sort();
        switch (false) {
        case !(this._buffer[data[1]] != null && data[2] != null):
          this.emit('update', this.keys.indexOf(data[1]), this.db[data[1]], data[1]);
          break;
        case !(this._buffer[data[1]] != null && data[2] == null):
          this.emit('delete', this.keys.indexOf(data[1]), this.db[data[1]], data[1]);
          break;
        default:
          this.emit('insert', this.keys.indexOf(data[1]), this.db[data[1]], data[1]);
        }
        if (data[2] == null) {
          delete this.db[data[1]];
          this.keys.slice(this.keys.indexOf(data[1]), 1);
          this.keys.sort();
        }
        this._buffer[data[1]] = true;
        return true;
      case 'c':
        this._historyMap[data[1] + "-" + data[2][2] + "-" + data[2][1]] = update;
        if (update[2] !== this.id) {
          if ((ref$ = this.db[data[1]]) != null) {
            ref$._update(data[2]);
          }
        }
        return true;
      }
    };
    return LArray;
  }(LBase));
  LBase.Array = LArray;
  LBase.register(LArray);
  module.exports = LArray;
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);

// Generated by LiveScript 1.2.0
(function(){
  var filter, LBase, utils, LMap, slice$ = [].slice;
  filter = require('scuttlebutt/util').filter;
  LBase = require('./base');
  utils = require('./utils');
  LMap = (function(superclass){
    var prototype = extend$((import$(LMap, superclass).displayName = 'LMap', LMap), superclass).prototype, constructor = LMap;
    function LMap(opts){
      this.opts = opts != null
        ? opts
        : {};
      LMap.superclass.call(this);
      this.db = {};
      this._hist = {};
      this._historyMap = {};
    }
    prototype._prefix = function(key){
      if (this.opts.prefix != null) {
        key = this.opts.prefix + ":" + key;
      }
      return key;
    };
    prototype._unprefix = function(key){
      if (this.opts.prefix != null) {
        key = key.substring(this.opts.prefix.length + 1);
      }
      return key;
    };
    prototype._checkPrefix = function(key){
      if (this.opts.prefix == null) {
        return true;
      }
      return key.substring(0, this.opts.prefix.length) === this.opts.prefix;
    };
    prototype._register = function(key, model, update){
      var this$ = this;
      update == null && (update = true);
      this.db[key] = model;
      model.on('_update', function(it){
        if (this$.db[key] === model) {
          return this$.localUpdate(['c', key, it]);
        }
      });
      if (update) {
        return this.localUpdate(['d', key, model.constructor.name.toLowerCase(), model.creationArgs()]);
      }
    };
    prototype.set = function(key, model){
      key = this._prefix(key);
      return this._register(key, model);
    };
    prototype.get = function(key){
      return this.db[this._prefix(key)];
    };
    prototype.applyUpdate = function(update){
      var data, ref$;
      data = update[0];
      switch (data[0]) {
      case 'c':
        if (!this._checkPrefix(data[1])) {
          return false;
        }
        this._historyMap[data[1] + "-" + data[2][2] + "-" + data[2][1]] = update;
        if ((ref$ = this.db[data[1]]) != null) {
          ref$._update(data[2]);
        }
        return true;
      case 'd':
        if (!this._checkPrefix(data[1])) {
          return false;
        }
        this._hist[data[1]] = update;
        if (data[2] === null) {
          delete this.db[data[1]];
        } else {
          if (this.db[data[1]] == null) {
            this._register(data[1], LBase.create.apply(LBase, [data[2]].concat(slice$.call(data[3]))), false);
          }
        }
        return true;
      default:
        return false;
      }
    };
    prototype.history = function(sources){
      var hist, key, ref$, update, val, this$ = this;
      hist = [];
      for (key in ref$ = this._hist) {
        update = ref$[key];
        if (!~hist.indexOf(update) && filter(update, sources)) {
          hist.push(update);
        }
      }
      for (key in ref$ = this._db) {
        val = ref$[key];
        hist = hist.concat(val.history(sources).map(fn$));
      }
      return hist.filter(Boolean).sort(utils.order);
      function fn$(update){
        return this$._historyMap[key + "-" + update[2] + "-" + update[1]];
      }
    };
    return LMap;
  }(LBase));
  LBase.Map = LMap;
  LBase.register(LMap);
  module.exports = LMap;
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
